/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 21-world/public/dice.glb --transform --simplify 
Files: 21-world/public/dice.glb [776.58KB] > /Users/matt/Desktop/code/what-i-love/dice-transformed.glb [42.16KB] (95%)
*/

import React, {
    useRef,
    useImperativeHandle,
    forwardRef,
    useEffect,
    useMemo,
    useState
} from 'react'
import { useGLTF, Text } from '@react-three/drei'
import { RigidBody, CuboidCollider } from '@react-three/rapier'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import { ArrowArea } from './ArrowArea'


function DiceModel() {
    const { nodes, materials } = useGLTF('/dice.glb')
    return (
        <group dispose={null} scale={0.2}>
            <mesh geometry={nodes.Cube_1.geometry} material={materials.Dot} />
            <mesh geometry={nodes.Cube_2.geometry} material={materials.Dice} />
            <mesh geometry={nodes.Cube_3.geometry} material={materials['Red Dot']} />
        </group>
    )
}

useGLTF.preload('/dice.glb')

// ─── DICE ROLLER (Two Dice with Physics) ─────────────────────────
// We wrap our two dice in Rapier RigidBodies and expose a rollDice() method.
export const DiceRoller = forwardRef((props, ref) => {
    const dice1 = useRef()
    const dice2 = useRef()

    useImperativeHandle(ref, () => ({
        rollDice: () => {
            // Replace the original impulse/torque definitions with these:
            const impulse1 = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(0.2),  // Horizontal impulse: from -0.1 to 0.1
                THREE.MathUtils.randFloat(0.2, 0.3),     // Vertical impulse: between 0.2 and 0.3
                THREE.MathUtils.randFloatSpread(0.2)
            )
            const torque1 = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(0.1),
                THREE.MathUtils.randFloatSpread(0.1),
                THREE.MathUtils.randFloatSpread(0.1)
            )
            const impulse2 = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(0.2),
                THREE.MathUtils.randFloat(0.2, 0.3),
                THREE.MathUtils.randFloatSpread(0.2)
            )
            const torque2 = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(0.1),
                THREE.MathUtils.randFloatSpread(0.1),
                THREE.MathUtils.randFloatSpread(0.1)
            )

            // Apply the impulses to each dice.
            dice1.current.applyImpulse(impulse1, true)
            dice1.current.applyTorqueImpulse(torque1, true)
            dice2.current.applyImpulse(impulse2, true)
            dice2.current.applyTorqueImpulse(torque2, true)
        }
    }))

    return (
        <>
            <RigidBody
                ref={dice1}
                colliders="cuboid"
                position={[-24.5, 2, 0]} // adjust starting positions as needed
                restitution={0.1}
                friction={1.}
            >
                <DiceModel />
            </RigidBody>
            <RigidBody
                ref={dice2}
                colliders="cuboid"
                position={[-25.5, 2, 0]}
                restitution={0.1}
                friction={1.}
            >
                <DiceModel />
            </RigidBody>
        </>
    )
})

// ─── OPTIONAL: If you want this file to be the dice entry point ───
export default function Dice() {
    const diceRef = useRef()

    return (
        <>
            <DiceRoller ref={diceRef} />


            <ArrowArea
                position={[-24.5, 0, 0]}
                onSpace={() => diceRef.current.rollDice()}  // trigger dice roll
                text="VIEW FULL VIDEO"
                isInstructionBox={false}
                textPosition={[-6.7, 0.38, 3.]}
            />
        </>

    )


}